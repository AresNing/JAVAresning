

# MySQL

## MySQL 服务启动

- 管理员运行`cmd`
  -  启动`mysql`服务：`net start mysql`
  -  关闭`mysql`服务：`net stop mysql`

## MySQL 登录

1. `mysql -uroot -p密码`
2. `mysql -hip -p连接目标的密码`
3. `mysql --host=ip --user=root --password=连接目标的密码`

## MySQL 退出

1. `exit`
2. `mysql -hip -p连接目标的密码`
3. `mysql --host=ip --user=root --password=连接目标的密码`

## 文件结构

- 数据库管理系统 -> 数据库 -> 表 -> 数据

# SQL

## 基本介绍

- Structure Query Language：结构化查询语言。定义了操作所有关系型数据库的规则
- 每一种数据库操作的方式存在不一样的地方

## 通用语法

- SQL 语句可以单据或多行书写，以分号结尾
- MySQL 数据库的 SQL 语句**不区分大小写**，**关键字建议使用大写**
- 3种注释方法
  1. 单行注释：`--(空格)注释内容`
  2. 单行注释（MySQL 特有）：`# 注释内容`
  3. 多行注释：`/* 注释 */`

## SQL 分类

- DDL（Data Definition Language）数据定义语言：用来定义数据库对象：数据库，表，列等。关键字：`create`，` drop`，` alter` 等
- DML（Data Manipulation Language）数据操作语言：用来对数据库中表的数据进行增删改。关键字：`insert`，`delete`，`update`等
- DQL（Data Query Language）数据查询语言：用来查询数据库中表的记录(数据)。关键字：`select`，`where`等
- DCL（Data Control Language）数据控制语言（了解）：用来定义数据库的访问权限和安全级别，及创建用户。关键字：`GRANT`， `REVOKE`等

# DDL：操作数据库、表

## 操作数据库（CRUD）

1. C（Create）：创建

   - 创建数据库

     ```sql
     CREATE DATABASE 数据库名;
     ```

   - 创建数据库，判断不存在，再创建

     ```sql
     CREATE DATABASE if not exists 数据库名;
     ```

   - 创建数据库，并指定字符集

     ```sql
     CREATE DATABASE 数据库名 CHARACTER SET 字符集名;
     ```

   - 创建数据库，判断是否存在，并指定字符集

     ```sql
     CREATE DATABASE if not exists 数据库名 CHARACTER SET 字符集名; 
     ```

2. R（Retrieve）：查询

   - 查询所有数据库的名称

     ```sql
     SHOW DATABASES;
     ```

   - 查询某个数据库的字符集 / 查询某个数据库的创建语句（定义信息）

     ```sql
     SHOW CREATE DATABASE 数据集名;
     ```

3. U（Update）：修改

   - 修改数据库默认的字符集

     ```sql
     ALTER DATABASE 数据库名 DEFAULT CHARACTER SET 字符集名;
     ```

4. D（Delete）：删除

   - 删除数据库

     ```sql
     DROP DATABASE 数据库名;
     ```

   - 判断数据库存在，存在再删除

     ```sql
     DROP DATABASE if exists 数据库名称;
     ```

5. 使用数据库

   - 查询当前正在使用的数据库名称

     ```sql
     SELECT DATABASE(); -- 使用的一个mysql中的全局函数
     ```

   - 使用/切换数据库

     ```sql
     USE 数据库名;
     ```

## 操作表（CRUD）

*前提先使用某个数据库*

1. C（Create）：创建

   ```sql
   CREATE TABLE 表名 (
   	字段1 数据类型1,
   	字段2 数据类型2,
   	...
   	字段n 数据类型n
   );
   ```

   复制表

   ```sql
   CREATE TABLE 表名 LIKE 被复制的表名;
   ```

   - 常用数据类型
     - `INT`
     - `DOUBLE(m, n)`：`m`为小数总位数，`n`为小数点后位数
     - `DATE`：日期，只包含年月日，`yyyy-MM-dd`
     - `DATETIME`：日期，只包含年月日时分秒，`yyyy-MM-dd HH:mm:ss`
     - `TIMESTAMP`：时间戳类型，包含年月日时分秒，`yyyy-MM-dd HH:mm:ss`；如不给该字段赋值，或赋值为`null`，则默认使用当前的系统时间
     - `VARCHAR(max)`：可变字符串，`max`为最大字符串

2. R（Retrieve）：查询

   - 查询某个数据库中所有的表名称

     ```sql
     SHOW TABLES;
     ```

   - 查询表结构

     ```sql
     DESC 表名;
     ```

   - 查询创建表的 SQL 语句

     ```sql
     SHOW CREATE TABLE 表名;
     ```

3. U（Update）：修改

   - 修改表名

     ```sql
     ALTER TABLE 表名 RENAME TO 新表名;
     ```

   - 修改表的字符集

     ```sql
     ALTER TABLE 表名 CHARACTER SET 字符集名;
     ```

   - 添加一列

     ```sql
     ALTER TABLE 表名 ADD 列名 数据类型;
     ```

   - 修改列名称 类型

     ```sql
     ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;
     ```

     ```sql
     ALTER TABLE 表名 MODIFY 列名 新数据类型;
     ```

   - 删除列

     ```sql
     ALTER TABLE 表名 DROP 列名;
     ```

4. D（Delete）：删除

   D（Delete）：删除

   - 删除表

     ```sql
     DROP TABLE 表名;
     ```

     ```sql
     DROP TABLE if exists 表名;
     ```

# DML：增删改表中数据

## 添加数据

```sql
INSERT INTO 表名(字段1, 字段2,...字段n) VALUES(值1, 值2,...值n);
```

- 字段名和值要一一对应

- 如果表名后不定义字段，则默认给所有列添加值

  ```sql
  INSERT INTO 表名 VALUES(值1, 值2,...值n);
  ```

- 除了数字类型，其他类型需要用引号（单双引号皆可）引起来

## 删除数据

```sql
DELETE FROM 表名 [WHERE 条件表达式];
```

- 如果不加条件，则删除表中所有记录

- 如果要删除所有记录

  ```sql
  DELETE FROM 表名; -- 不推荐使用, 效率低, 有多少条记录就会执行多少次删除操作
  ```

  ```sql
  TRUNCATE TABLE 表名; -- 推荐使用, 效率更高, 相当于想删除表, 然后再创建一张格式一样的表
  ```

## 修改数据

```sql
UPDATE 表名 SET 列名1 = 值1, 列名2 = 值2,... [WHERE 条件表达式];
```

- 如果不加任何条件，则会将表中所有记录全部修改

# DQL：查询表中的记录

```sql
SELECT
	字段列表
FROM
	表名列表
WHERE
	条件列表
GROUP BY
	分组字段
HAVING
	分组之后的条件
ORDER BY
	排序
LIMIT
	分页限定
```

## 基础查询

- 多个字段的查询

  ```sql
  SELECT 字段名1, 字段名2,... FROM 表名;
  ```

  - 如果查询所有字段，则可以使用*来替代字段列表

- 查询指定列且结果集不出现重复数据

  ```sql
  SELECT DISTINCT 字段名 FROM 表名;
  ```

- 查询结果参与运算

  ```sql
  SELECT 列名1 + 固定值 FROM 表名;
  ```

  ```sql
  SELECT 列名1 + 列名2... FROM 表名;
  ```

  - 一般只会进行数值型计算
  - `IFNULL(表达式1, 表达式2)`：`null`参与的运算，计算结果都为`null`，表达式1为哪个字段需要判断是否`null`，表达式2为如果该字段为`null`后的替换值

- 对列/表指定别名

  ```sql
  SELECT 字段1 AS 别名, 字段2 AS 别名,... FROM 表名 AS 表别名;
  ```

  - `AS`可以省略

## 条件查询

流程：取出表中的每条记录，满足条件的记录就返回，不满足条件的记录不返回

- `WHERE`子句后接条件

  ```sql
  SELECT 字段名 FROM 表名 WHERE 条件表达式;
  ```

- 运算符

  - `>, <, <=, >=, =, <>`：`<>`在 SQL 中表示不等于，在 MySQL 中也可以使用`!=`，没有`==`
  - `BETWEEN m AND n`：在`[m, n]`之间的范围中
  - `IN(数据1, 数据2,...)`：
  - `LIKE '通配符字符串'`：模糊查询
    - 通配符/占位符：`_` - 单个任意字符；`%` - 多个任意字符
  - `IS NULL`或`IS NOT NULL`：查询某一列为`null`的值，不能写成`=NULL`
  - `AND`或`&&`：与，SQL 中建议使用前者，后者并不通用
  - `OR`或`||`
  - `NOT`或`!`

## 排序查询

通过`ORDER BY`子句，可以将查询结果进行排序（排序只是显示方式，不会影响数据库中数据的顺序）

```sql
ORDER BY 排序字段1 排序方式1, 排序字段2 排序方式2...
-- 举例
SELECT * FROM tableName ORDER BY field1 ASC, field2 DESC;
```

- 排序方式：`ASC`升序，默认的；`DESC`降序
- 如果有多个排序条件，则当前一个的条件值一样时，才会判断第二条件

## 聚合函数

将一列数据作为一个整体，进行纵向的计算

```sql
SELECT Function(field) FROM tableName;
```

- `COUNT(列名)`：计算个数

  - 一般选择非空的列：主键
  - `count(*)`：不推荐使用

- `MAX(列名)`

- `MIN(列名)`

- `SUM(列名)`

- `AVG(列名)`：计算平均值

- 注意：聚合函数的计算，排除`null`值

  解决方案

  - 选择不包含`null`的列进行计算
  - `IFNULL(列名, 默认值)`函数

## 分组查询

```sql
SELECT 字段1, 字段2... FROM 表名 GROUP BY 分组字段 [HAVING 条件表达式];
```

- `GROUP BY`将分组字段结果中相同内容作为一组，并且返回每组的第一条数据，所以**单独分组没什么用处**
- 分组的目的就是为了统计，一般分组会跟聚合函数一起使用
- 注意：
  - **当我们使用某个字段分组，在查询的时候也需要将这个字段查询出来**，否则看不到数据属于哪组的
  - 分组之后查询的字段：分组字段、聚合函数
-  `WHERE`和`HAVING`的区别
  - `WHERE`在分组之前进行限定，`HAVING`在分组之后进行限定
  - `WHERE`后不可以跟聚合函数，`HAVING`后可以进行聚合函数的判定
- `GROUP BY`后面不能出现`WHERE`，使用`HAVING`

## 分页查询

`LIMIT`的作用是限制查询记录的条数

```sql
LIMIT offset, length; 
-- offset: 起始行数, 从0开始计数, 如果省略, 默认就是0
-- length: 返回的行数, 即返回的行数 <= length
```

- `LIMIT`是 MySQL 特有的

# 约束

对表中的数据进行限定，保证数据的正确性、有效性和完整性；约束在创建表的时候添加比较合适

## 非空约束 NOT NULL

某一列的值不能为`null`

- 基本语法

  ```sql
  CREATE TABLE 表名(
      字段名 字段类型 NOT NULL -- 创建表时添加非空约束
  );
```
  
```sql
  ALTER TABLE 表名 MODIFY 字段名 字段类型 NOT NULL; --   创建表完后, 添加非空约束
  ALTER TABLE 表名 MODIFY 字段名 字段类型; -- 删除非空约束
  ```
  
- 默认值

  ```sql
  CREATE TABLE 表名(
      字段名 字段类型 DEFAULT 默认值  -- 创建表时设置默认值
  );
  ```

## 唯一约束 UNIQUE

某一列的值不能重复

- 基本语法

  ```sql
  CREATE TABLE 表名(
      字段名 字段类型 UNIQUE -- 创建表时添加唯一约束
  );
  ```

  - 注意：唯一约束可以有`null`值，但是只能有一条记录为`null`

  ```sql
  ALTER TABLE 表名 MODIFY 字段名 字段类型 UNIQUE; -- 创建表完后, 添加唯一约束
  ALTER TABLE 表名 MODIFY 字段名 字段类型; -- 删除唯一约束
  ```

## 主键约束 PRIMARY KEY

**通常不用业务字段作为主键，单独给每张表设计一个`id`的字段，把`id`作为主键**。主键是给数据库和程序使用的，不是给最终的客户使用的。所以主键有没有含义没有关系，只要不重复，非空就行

- 基本语法

  ```sql
  CREATE TABLE 表名(
      字段名 字段类型 PRIMARY KEY -- 创建表时添加主键约束
  );
  ```

  - 注意：
    - 主键约束是非空且唯一
    - 一张表只能有一个字段为主键
    - 主键是表中记录的唯一标识

  ```sql
  ALTER TABLE 表名 MODIFY 字段名 字段类型 PRIMARY KEY; -- 创建表完后, 添加主键约束
  ALTER TABLE 表名 DROP PRIMARY KEY; -- 删除唯一约束
  ```

- 主键自增

  `AUTO_INCREMENT`：在每次插入新记录时，数据库自动生成主键字段的值（字段类型必须是整数类型）

  ```sql
  CREATE TABLE 表名(
      id INT PRIMARY KEY AUTO_INCREMENT
  ) AUTO_INCREMENT = 起始值; -- 创建表时指定起始值
  ```

  - `AUTO_INCREMENT`的默认值为`1`

  ```sql
  ALTER TABLE 表名 MODIFY 字段名 字段类型 AUTO_INCREMENT; -- 创建表完后, 添加自动增长
  ALTER TABLE 表名 MODIFY 字段名 字段类型; -- 删除自动增长
  ALTER TABLE 表名 AUTO_INCREMENT = 起始值; -- 创建表之后修改起始值
  ```

- `DELETE`和`TRUNCATE`对自增长的影响

  - `DELETE`：删除所有的记录之后，自增长没有影响（继续增长）
  - `TRUNCATE`：删除以后，自增长又重新开始（从初始值开始）

## 外键约束 FOREIGN KEY

外键：在副表/从表中与主表主键对应的那一列，即副表/从表的外键关联了主表的主键，副表/从表的外键被主表的主键约束

- 基本语法

  ```sql
  [CONSTRAINT] [外键约束名称] FOREIGN KEY(外键字段名) REFERENCES 主表名(主键字段名)
  -- 在创建表时添加外键
  CREATE TABLE 表名(
  				....
  				外键列,
  				CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称)
  			);
  ```

  ```sql
  ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; -- 删除外键
  ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称); -- 创建表之后, 添加外键
  ```

- 外键的级联操作

  ```sql
  -- 在创建外键时, 添加级联操作
  ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE;
  ```

  - `ON UPDATE CASCADE`：级联更新
  - `ON DELETE CASCADE`：级联删除
  - **在开发中谨慎使用级联操作**

- **在开发中不推荐使用外键，因为外键会大大降低检索效率，增加查询时间，这是交叉查询不允许的**

# 多表关系

## 一对多

- 班级-学生、部门-员工、分类-商品...
- 一对多关系的建表原则：在从表（多方）创建一个字段，字段作为外键指向主表（一方）的主键

## 多对多

- 老师-学生、学生-课程、用户-角色

- 多对多关系的建表原则：**需要创建第三张表 -- 中间表**，中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键

  ![多对多关系建表原则](pics/image-20210714143516568.png)

- 创建复合主键

  ```sql
  PRIMARY KEY(字段1, 字段2...), -- 创建表时, 创建复合主键
  ```



## 一对一

- 一对一关系在开发中应用不多，因为一对一关系可以创建成一张表
- 一对一关系的建表原则
  - 外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一`UNIQUE`
  - 外键是主键：主表的主键和从表的主键，形成主外键关系

# 数据库设计的范式

## 基本概念

- 设计关系数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求
- 不同的规范要求被称为不同的范式，**各种范式呈递次规范，越高的范式数据库冗余越小**
- 目前关系数据库有**六种范式**（NF，Normal Form）
  1. 第一范式（1NF）
  2. 第二范式（2NF）
  3. 第三范式（3NF）
  4. 巴斯-科德范式（BCNF）
  5. 第四范式(4NF）
  6. 第五范式（5NF，又称完美范式）
- **一般说来，数据库只需满足第三范式(3NF）即可**

## 1NF

- **第一范式每一列不可再拆分，称为原子性**
- 数据库表的每一列都是不可分割的原子数据项，不能是集合、数组等非原子数据项
- 表中的某个列有多个值时，必须拆分为不同的列

## 2NF

- **2NF是在1NF的基础上所有列完全依赖于主键列，不产生局部依赖**
- 当存在一个复合主键包含多个主键列的时候，才会发生不符合第二范式的情况
- 2NF的特点：
  1. 一张表只描述一件事情
  2. 表中的每一列都完全依赖于主键

## 3NF

- **3NF在2NF的基础上，表中的每一列都直接依赖于主键，而不是通过其它的列来间接依赖于主键，不产生传递依赖**
- 满足3NF的数据库表不存在如下依赖关系：主键列 -> 非主键列 x -> 非主键列 y

# 数据库备份和还原

## 命令行

- 备份

  ```sql
  $ mysqldump -u用户名 -p密码 需要备份的数据库名称 > 保存路径
  ```

- 还原

  1. 登录数据库

     ```sql
     $ mysql -u用户名 -p密码
     ```

  2. 创建新数据库

     ```sql
     $ CREATE DATABASE 数据库名
     ```

  3. 使用新数据库

     ```sql
     $ USE DATABASE 数据库名
     ```

  4. 执行文件还原

     ```sql
     $ SOURCE 文件路径
     ```

















