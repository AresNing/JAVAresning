# 数据类型

## 整数/浮点数类型

- 整数类型默认是`int`，定义`long`型变量后面要加上`l`或`L`

- 浮点型默认是`double`，定义`float`型变量后面要加上`f`或`F`

- 浮点数使用陷阱：对运算结果是小数的进行相等判断时，须小心，小数运算为精度存储；应该是以两个数的差值的绝对值，在某个精度范围内判断

  ```java
  double num1 = 2.7
  double num2 = 8.1 / 3
  //不应该写成
  if(num1 == num2){...}
  //应该写成
  eps = ...//精度值
  if(Math.abs(num1 - num2) < eps)
  ```

## 字符型

- 字符型存储到计算机中，需要将字符对应的码值（整数）找出来，字符和码值的对应关系是通过字符编码表决定的

- 字符编码表

  - ASCII：1个字符使用1个字节，一共128个字符（实际上可表示256个字符）
  - Unicode：固定大小的编码，字符使用2个字节（一共65536个字符），字母和汉字统一都是占用2个字节（某些情况下浪费空间）
  - UTF-8：大小可变的编码表（可用1-6个字节表示字符），字母使用1个字节，汉字使用3个字节
  - GBK：可表示汉字，且范围广，字母使用1个字节，汉字使用2个字节
  - GB2312：可表示汉字，范围 gb2312 < gbk
  - BIG5：繁体中文，台湾，香港

- 比较两个字符串是否相同

  ```java
  String s1;
  String s2;
  s1.equals(s2) -> 相同，返回true；不同，返回false
  ```

  

## 布尔类型

- 不可以用0或非0的整数替代`false`和`true`，与C语言不同

## 自动类型转换

- java程序进行赋值或运算时，精度小的类型自动转换为精度大的数据类型

  - `char -> int -> long -> float -> double`

  - `byte -> short -> int -> long -> float -> double`
  - `char`和`byte/short`之间不会相互转换
  - `boolean`不参与转换

- 多种类型数据混合运算时，系统首先自动将所有数据转换成容量最大的数据类型，然后再进行计算

  - `char, byte, short`三者可以参与计算，在计算时首先转换为`int`类型

    ```java
    byte b1 = 1;
    byte b2 = 2;
    byte b3 = b1 + b2; //Error, b1 + b2 -> int
    ```

## 基本数据类型与String类型的转换

- 基本数据类型转String类型

  - 语法：基本类型的值 + ""

    ```java
    int n1 = 100;
    boolean b1 = true;
    String s1 = n1 + "";
    String s2 = b1 + "";
    ```

- String类型转基本数据类型

  - 语法：通过基本类型的包装类调用`parseXX`方法即可

    ```java
    String s1 = "123";
    int num1 = Integer.parseInt(s1);
    double num2 = Double.parseDouble(s1);
    float num3 = Float.parseFloat(s1);
    long num4 = Long.parseLong(s1);
    byte num5 = Byte.parseByte(s1);
    boolean b6 = Boolean.parseBoolean("true");
    short num6 = Short.parseShort(s1);
    //在字符串中提取字符
    char c1 = s1.charAt(0);
    ```

# 算术运算符

- `++`

  - 独立语句使用，`i++`和`++i`都等价于`i = i + 1`

  - 自增（前）：先运算后取值

    ```java
    a = 2;
    b = ++ a; //a = 3, b = 3
    ```

  - 自增（后）：先取值后运算

    ```java
    a = 2;
    b = a ++; //a = 3, b = 2
    ```

  ![自增自减](pics/i++.jpg)

- `--`

  - 独立语句使用，`i--`和`--i`都等价于`i = i - 1`

  - 自增（前）：先运算后取值

    ```java
    a = 2;
    b = -- a; //a = 1; b = 1 
    ```

  - 自增（后）：先取值后运算

    ```java
    a = 2;
    b = a --; //a = 1; b = 2 
    ```

- `%`取模取余的本质：`a % b = a - a / b * b`

  ```java
  10 % 3 = 1;
  -10 % 3 = -1;
  10 % -3 = 1;
  -10 % -3 = -1;
  ```

# 逻辑运算符

- `^`异或
  - 两个条件不同，结果为`true`，否则为`false`
  - 不进位的二进制加法
- `&&`和`&`的使用区别
  - `&&`短路与：如果第一个条件为`false`，则第二个条件不会判断，最终结果为`false`，效率高
  - `&`逻辑与：不管第一个条件是否为`false`，第二个条件都要判断，效率低
  - 开发中，我们使用的基本是`&&`短路与，效率高
- `||`和`|`的使用区别
  - `||`短路或：如果第一个条件为`true`，则第二个条件不会判断，最终结果为`true`，效率高
  - `&`逻辑与：不管第一个条件是否为`true`，第二个条件都要判断，效率低
  - 开发中，我们使用的基本是`||`短路或，效率高

# 标识符的命名规则和规范

## 标识符的命名规则

- 由26个英文字母大小写，0-9，_或$组成
- 数字不可以开头
- 不可以使用关键字和保留字
- 严格区分大小写
- 标识符不能包含空格

## 标识符的命名规范

- 包名：多单词组成时所有字母都小写：`aaa.bbb.ccc`
- 类名、接口名：多单词组成时，所有单词的首字母大写：`XxxYyyZzz`
- 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：`xxxYyyZzz`（驼峰法）
- 常量名：所有字母都大写，多单词组成时每个单词用下划线连接：XXX_YYY_ZZZ

# 二进制运算

## 原码、反码、补码

- 二进制最高位是符号位，0表示正数，1表示负数
- 正数和0的原码、反码、补码都一样（三码合一）
- 负数的反码 = 它的原码符号位不变，其它位取反
- 负数的补码 = 它的反码 + 1，负数的反码 = 负数的补码 - 1
- java没有无符号数，java中的数都是有符号的
- 计算机是以补码的方式来运算的
- 运算结果要看它的原码

## 位运算符

- 算术右移`>>`：低位溢出，符号位不变，并用符号位补溢出的高位
- 算术左移`<<`：符号位不变，低位补0
- 逻辑右移`>>>`：无符号右移，低位溢出，高位补0（没有`<<<`符号）

# switch注意事项

- `switch(表达式)`中的表达式数据类型，应和`case`后的常量类型一致，或者是可以自动转成可以相互比较的类型
- `switch(表达式)`中的表达式的返回值必须是：`byte,short,int,char,enum[枚举],String`
- `case`子句中的值必须为常量，不能是变量
- `default`子句是可选的，当没有可匹配的`case`时，执行`default`
- `break`语句用来在执行完一个`case`分支后使程序跳出`switch`语句块；如果没有`break`，程序会顺序执行到`switch`结尾，除非遇到`break`

# break注意事项

- `break`语句出现在多层嵌套语句块中，可通过标签指明要终止的是哪一层语句块

  （`continue`也有类似的用法）

  ![break注意事项](pics/image-20210525204026975.png)

- 实际开发中，尽量不要使用标签

# 数组

## 数组声明

```java
// 第一种(静态初始化)：数据类型[] 数组名 = {};(更符合java习惯) 
// 或 数据类型 数组名[] = {};
type[] arrayname = {a1,a2,a3,...};
type arrayname[] = {a1,a2,a3,...};

// 第二种(动态初始化)：数据类型[] 数组名 = new 数据类型[大小];
// 或 数据类型 数组名[] = new 数据类型[大小];
type[] arrayname = new type[arraysize];
type arrayname[] = new type[arraysize];

// 第三种(动态初始化:先声明后创建)：数据类型[] 数组名; 数组名 = new 数据类型[大小]； 
// 或 数据类型 数组名[]; 数组名 = new 数据类型[大小]；
type[] arrayname;
arrayname = new type[arraysize];

type arrayname[];
arrayname = new type[arraysize];
```

## 数组注意事项

- 数组属于引用类型，数组型数组是对象（`object`）

- 数组创建后，如果没有赋值，有默认值（如`boolean false`）

- 数组在默认情况下是引用传递，赋的值是地址

  ![数组的引用传递](pics/image-20210526121509530.png)

# 二维数组

## 二维数组声明

```java
// 第一种(静态初始化)：数据类型[][] 数组名 = {};(更符合java习惯) 
// 或 数据类型 数组名[][] = {};
type[][] arrayname = {{a1,a2},{a3,...},...;
type arrayname[][] = {{a1,a2},{a3,...},...;

// 第二种(动态初始化)：数据类型[][] 数组名 = new 数据类型[大小][大小];
// 或 数据类型 数组名[][] = new 数据类型[大小][大小];
type[][] arrayname = new type[arraysize][arraysize];
type arrayname[][] = new type[arraysize][arraysize];

// 第三种(动态初始化:先声明后创建)：数据类型[][] 数组名; 数组名 = new 数据类型[大小][大小]； 
// 或 数据类型 数组名[][]; 数组名 = new 数据类型[大小][大小]；
type[][] arrayname;
arrayname = new type[arraysize][arraysize];

type arrayname[][];
arrayname = new type[arraysize][arraysize];
  
// 第四种(动态初始化:列数不确定)：数据类型[][] 数组名 = new 数据类型[大小][]； 
// 或 数据类型 数组名[][] = new 数据类型[大小][]；
type[][] arrayname = new type[arraysize][];
type arrayname[][] = new type[arraysize][];                
```

## 二维数组注意事项

- 一维数组的声明方式有：`int[] x`或者`int x[]`

- 一维数组的声明方式有：`int[][] y`或者`int[] y[]`或者`int y[][]`

- 二维数组内存形式

  ![二维数组内存形式](pics/image-20210526122643576.png)

# 冒泡排序

```java
public class BubbleSort {

	public static void main(String[] args) {

		int[] nums = {24, 69, 80, 57, 13};
        int temp = 0; //辅助交换的变量

        //多轮排序用外层循环
		for(int i = 0; i < nums.length-1; i++) {
			//单轮排序次数逐次减小
			for(int j = 0; j < nums.length-1-i; j++) {
				//若前面的数大于后面的数，交换数值
				if(nums[j] > nums[j+1]) {

					temp = nums[j];
					nums[j] = nums[j+1];
					nums[j+1] = temp;
				}
			}
		}
		//输出
		for(int i = 0; i < nums.length; i++) {

			System.out.print(nums[i]+" ");
		}
	}
}
```

# 类与对象

- 类：自定义的数据类型

  - 类包括**属性/成员变量**，**行为/成员方法**，**构造器**

  ```java
  package 包名;
  class 类名 {
      成员变量/属性;
      构造器;
      成员方法;
  }
  ```

  

- 对象：类的具体实例

  - 从**类**到**对象**，有几种说法：创建一个对象；实例化一个对象；把类实例化...

## 对象的内存形式

**注意：**

- Java6和6之前，常量池是存放在方法区（永久代）中的

- Java7，将常量池是存放到了堆中

- **Java8之后**，取消了整个永久代区域，取而代之的是元空间；

  **运行时常量池和静态常量池存放在元空间中，而字符串常量池依然存放在堆中**

![对象的内存形式](pics/image-20210526133238638.png)

## 属性/成员变量/字段field

- 属性一般是基本数据类型，也可以是引用类型（对象，数组）
- 属性的定义语法同变量，利用**修饰符**控制属性的访问范围（`public`，`protected`，默认，`private`）
- 属性如果不赋值，有默认值，规则同数组

## 对象的创建

```java
// 第一种(直接创建)：类名 对象名 = new 类名(); 
ClassName objectName = new ClassName();

// 第二种(先声明再创建)：类名 对象名; 对象名 = new 类名(); 
ClassName objectName;
objectName = new ClassName();
```

## 类和对象的内存分配机制

- java内存的结构分析
  - 栈：一般存放基本数据类型（局部变量）
  - 堆：存放对象（类的对象，数据等）和字符串常量
  - 方法区/元空间：常量池，类加载信息

## 成员方法/方法

- 方法：对象可以执行的动作
- 好处
  - 提高代码的复用性
  - 可以将实现的细节封装起来，然后供其他用户来调用即可

## 成员方法的调用机制原理

![方法的调用机制原理](pics/image-20210526153919347.png)

- 当程序运行到方法时，就会开辟一个独立的空间（栈空间）

## 成员方法的定义

```java
/*访问修饰符 返回数据类型 方法名(形参列表) {
	语句；
 	return 返回值；
 }
 */
```

- 形参列表：表示成员方法输入
- 返回数据类型：表示成员方法输出, `void`表示没有返回值
- 方法主体：表示为了实现某一功能代码块
- `return`语句不是必须的
- 访问修饰符：作用是控制方法使用的范围（`public`，`protected`，默认，`private`）

## 成员方法的注意事项

- 方法里**不能嵌套**另一个方法的**定义**，可以**调用**别的方法

  - 方法调用细节

    - 同一个类中的方法调用：直接调用即可，`method.()`

    - 跨类中的方法调用：需要先创建对象，再通过对象名调用，（还与访问修饰符有关）

      `ClassName objectName = new ClassName(); objectName.method()`

- 一个方法最多有一个返回值；若需返回**多个结果**，返回**数组**

- 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象)

- 方法名遵循驼峰命名法

## 成员方法传参机制

- 基本数据类型的传参：传递的是值（值拷贝），形参的任何改变不影响实参（独立内存空间）
- 引用数据类型（数组，对象）的传参：传递的是地址，可以通过形参影响实参（地址指向相同内存空间）
- 成员方法返回类型是引用类型时，注意其对应的内存空间

## 方法递归调用

![方法递归调用](pics/image-20210526191012084.png)

- 要点：找准递归结束条件
- 实例：斐波那契数列，吃桃子问题，迷宫问题（递归回溯），汉诺塔问题，八皇后问题（递归回溯）

## 方法重载（OverLoad）

- java中允许同一个类中，多个同名方法的存在，但要求形参列表不一致
- 方法名：必须相同
- 形参列表：必须不同（形参类型或个数或顺序，至少一样不同，参数名无要求）
- 返回类型：无要求

## 可变参数

- java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法，就可以通过可变参数实现

- 基本语法

  ```java
  //访问修饰符 返回类型 方法名(数据类型... 形参名) {
  //}
  //求和n个数，n个数存放在nums数组
  public int sum(int... nums) {
      int res = 0;
      for(int i = 0; i < nums.length; i++) {
          res += nums[i];
      }
      return res;
  }
  ```

- 可变参数的本质就是数组
- 可变参数的实参可以为0个或任意多个
- 可变参数可与不同类型的参数一起放在形参列表，但可变参数必须在最后
- 一个形参列表中只能出现一个可变参数

# 作用域

## 基本使用

- java中，主要的变量是属性/成员变量/全局变量和局部变量
- 局部变量一般是指在成员方法中定义的变量
- java中作用域的分类
  - 全局变量/属性：作用域为整个类体，或被其他类使用（通过对象调用）
  - 局部变量：就是除了属性外的其他变量，作用域为定义它的代码块中
- 全局变量/属性可以不赋值，直接使用，因为有默认值；局部变量必须赋值后才能使用，因为没有默认值

## 作用域的注意事项

- 属性和局部变量可以重名（因为不在同一个作用域），访问时遵循就近原则

- 在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名

- 属性的生命周期较长，伴随着对象的创建/销毁而创建/销毁；

  局部变量的生命周期较短，伴随着代码块的执行/结束而创建/销毁，即再一次方法调用中

- 全局变量/属性可以加修饰符；

  局部变量不可以加修饰符

# 构造方法/构造器constructor

- 作用：创建对象时，就直接赋值对象的属性（完成对象的初始化）

## 基本语法

与成员方法类似

```java
/*访问修饰符 方法名(形参列表) {
	方法体;
 }
 */
```

- 构造器的修饰符：`默认,public,protected,privated`
- **构造器没有返回值**
- **构造器的方法名与类名一致**
- 参数列表和成员方法一样的规则
- 构造器的调用由系统执行

## 构造器的注意事项

- 一个类可以定义多个不同的构造器，即构造器重载

- **构造器没有返回值**

- **构造器的方法名与类名一致**

- 构造器是完成对象的初始化，并不是创建对象

- 如果没有定义构造器，系统会自动给类生成一个默认无参构造器（也叫默认构造器），可以使用`javap`反编译指令进行查看

  ```java
  class ClassName {
      /*
      默认构造器
      ClassName() {
      }
      */
  }
  ```

- **一旦自定义了构造器，默认构造器就被覆盖了（无法再使用默认构造器），除非显式的定义它，即`ClassName() {}`**(相当于构造器重载)

# 对象创建的流程分析

## 流程分析

![流程分析](pics/image-20210527160742154.png)

1. 在方法区/元空间里加载类信息，只会加载一次
2. 在堆中分配空间（地址）
3. 完成对象初始化：默认初始化 -> 显式初始化 -> 构造器的初始化
4. 在对象在堆中的地址，返回给创建的对象

![流程分析](pics/image-20210527160815545.png)

# this 关键字

- jvm会给每个对象分配`this`，`this`代表当前对象，`this.objectName`代表当前对象的属性；哪个对象被调用，`this`就代表哪个对象

- 用处：`this`用于区分当前类的属性和局部变量

  举例：构造器的形参能够直接写成属性名（并将形参赋值给`this.objectName`），解决了作用域的问题

## hashCode() 方法

- 使用`hashCode()`，以hashCode为格式返回对象的地址

## this 关键字的注意事项

- `this`关键字可以用来访问本类的**属性**、**方法**、**构造器**
- 访问成员方法的语法：`this.methodName(parametersList);`
- 访问构造器的语法：`this(parametersList);`（**只能在构造器中使用，即只能在构造器中访问其他构造器，并且对`this`的调用必须是构造器中的第一个语句**）
- `this`不能在类定义的外部使用，只能在类定义的方法中使用

# 包

## 作用

- 区分相同名字的类
- 当类很多时，可以很多的管理类
- 控制访问范围

## 基本语法

```java
package com.companyname;
// package 关键字,表示打包
//com.companyname 表示包名(com是company的缩写)
```

## 包的本质

- 包的本质：实际上就是创建不同的文件夹/目录保存类文件

## 包的命名

- 命名规则

  - 只能包含数字、字幕、下划线、小圆点

  - 不能用数字开头，不能是关键字或保留字

- 命名规范

  - 一般是小写字母+小圆点

  - 一般是`com.公司名.项目名.业务模块名`

    ```java
    // 举例
    com.sina.crm.user //用户模块
    com.sina.crm.utils //订单模块
    ```

## 包的引入

```java
// 举例
import java.util.Scanner; // 只是引入一个类Scanner
import java.util.*; // 表示将java.util包的所有类都引入
```

- 需要使用哪个类，就导入哪个类即可，不建议使用`*`导入

## 包的注意事项

- `package`的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多一句`package`
- `import`指令需放在`package`的下面，在类定义前面，`import`指令可以有多句且没有顺序要求

# 访问修饰符

| 访问级别 | 访问控制修饰符 | 同类               | 同包               | 子类               | 不同包             |
| -------- | -------------- | ------------------ | ------------------ | ------------------ | ------------------ |
| 公开     | `public`       | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: |
| 受保护   | `protected`    | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: | :x:                |
| 默认     | 没有修饰符     | :heavy_check_mark: | :heavy_check_mark: | :x:                | :x:                |
| 私有     | `private`      | :heavy_check_mark: | :x:                | :x:                | :x:                |

## 访问修饰符的注意事项

- 修饰符可以用来修饰类中的**属性**，**成员方法**以及**类**
- **只有默认的和`public`才能修饰类**

# 封装encapsulation









