# synchronized 关键字简介

- `synchronized`关键字可以保证被它修饰的方法或者代码块在任意一个时刻只能有一个线程执行
- 在 Java SE 1.6 之前，`synchronized`属于重量级锁，效率低下
  - 因为监视器锁`monitor`是依赖于操作系统的互斥锁来实现的，如果要挂起或唤醒一个线程，需要操作系统从用户态转换为内核态，状态转换的时间成本较高
- 在 Java SE 1.6 之后，对`synchronized`进行了优化：引入了偏向锁、轻量级锁，以及锁升级

# synchronized 的使用

- 修饰实例方法，给当前对象实例加锁
- 修饰静态方法，给当前类加锁
- 修饰代码块，指定加锁对象，对给定对象/类加锁

## 构造方法不能使用 synchronized 修饰

- 构造方法本身就是线程安全的，不存在同步的构造方法的说法

## 双重检验锁实现单例模式

```java
public class Singleton {
    private volatile static Singleton uniqueInstance;
    private Singleton() {
    }
    public static Singleton getUniqueInstance() {
        // 先判断对象是否已经被实例过了，没有实例化过才进入加锁代码
        if(uniqueInstance == null) { // 第一重检验
            // 类对象加锁
            synchronized (Singleton.class) {
                if(uniqueInstance == null) { // 第二重检验
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

- `synchronized`给单例对象加锁
- `uniqueInstance` 采用 `volatile` 关键字修饰是为了禁止 JVM 的指令重排，保证在多线程环境下也能正常运行

# synchronized 原理

- `synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置
  - 在执行`monitorenter`时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1
  - 在执行 `monitorexit` 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止
- `synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，而是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法
- 两者的本质都是对对象监视器 monitor 的获取

# Java 对象头（存储锁类型）

- 在 HotSpot 虚拟机中，对象在内存中的布局分为三块区域：对象头，实例数据和对齐填充
- 对象头中包含两部分：MarkWord 和 类型指针。如果是数组对象的话，对象头还有一部分是存储数组的长度
  - 多线程下 synchronized 的加锁就是对同一个对象的对象头中的 MarkWord 中的变量进行CAS操作

#  JDK1.6 之后对 synchronized 关键字的优化

> [Java6及以上版本对synchronized的优化](https://www.cnblogs.com/wuqinglong/p/9945618.html)

- 锁的分类（从低到高）：无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁
- 锁可以升级，不能降级

## 偏向锁

- 偏向锁是针对于一个线程而言的，线程获得锁之后就不会有解锁等操作了，节省很多开销；如果有两个线程来竞争该锁，那么偏向锁失效，升级为轻量级锁
- 引入偏向锁的原因：大部分情况下，都是同一线程进入同一块同步代码块
- 加锁：使用 CAS 将 Mark Word 中的线程 ID 设置为当前的线程 ID，若成功则获取偏向锁成功，若失败则进行锁升级
- 解锁：撤销偏向的操作需要在全局安全点执行。假设线程 A 曾经拥有锁（不确定是否释放锁）， 线程 B 来竞争锁对象，如果当线程 A 不再拥有锁时或者死亡时，线程 B 直接去尝试获得锁；如果线程 A 仍拥有锁，那么锁升级为轻量级锁，线程 B 自旋请求获得锁

## 轻量级锁

- 之所以是轻量级，是因为仅仅使用 CAS 进行操作，实现获取锁
- 加锁：
  - 线程在执行同步块之前，JVM 会先在当前线程的栈帧中创建存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，称为 Displaced Mark Word
  - 线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针，如果成功，当前线程获得轻量级锁；如果失败，虚拟机就会检查当前对象头的 Mark Word 是否指向当前线程的栈帧，如果指向，说明当前线程已获得这个对象的锁，可直接进入同步代码块，否则表示其他线程竞争锁，当前线程则尝试使用自旋获取锁。当竞争线程的自旋次数达到阈值时，轻量级锁膨胀为重量级锁
- 解锁：解锁时，会使用 CAS 操作将 Displaced Mark Word 替换回对象头，如果成功，则表示没有竞争发生；如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁

## 重量级锁

- 重量级锁是使用操作系统互斥量（mutex）来实现的传统锁
- 与轻量级锁不同，竞争的线程不在通过自旋来竞争线程，而是直接进入阻塞状态，此时不消耗 CPU，等到拥有锁的线程释放锁后，唤醒阻塞的线程，然后线程再次竞争锁
- 当锁膨胀到重量级锁时，就不能再回到轻量级锁

## 锁的优缺点对比

| 锁       | 优点                                                         | 缺点                                         | 适用场景                           |
| -------- | ------------------------------------------------------------ | -------------------------------------------- | ---------------------------------- |
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块的场景 |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度                     | 若始终得不到锁竞争的线程，使用自旋会消耗 CPU | 追求响应速度，同步块执行速度非常快 |
| 重量级锁 | 线程竞争不消耗 CPU，不会消耗 CPU                             | 线程阻塞，响应速度慢                         | 追求吞吐量，同步块执行时间较长     |

# synchronized 和 ReentrantLock 的区别



