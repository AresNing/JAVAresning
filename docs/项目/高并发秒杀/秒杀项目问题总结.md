> 问题总结（主要从三个方面：项目本身的问题、可能出现的问题、可改进的地方）

# 1.项目本身的问题

## 画一下项目的架构图

## 讲一下秒杀流程

1. 用户登录，进入商品列表页面
2. 点击进入商品详情页面
3. 点击秒杀，将验证码结果和商品 ID 传给后端
   - 如果结果正确，动态生成随机串 UUID，结合用户 ID 和商品 ID 存入 redis，并将秒杀 path 传给前端；前端获取秒杀 path 后，再根据秒杀 path 地址调用秒杀服务
4. 服务端获取请求的 path 参数，去查缓存是否存在 path
5. 如果 path 存在且 redis 有库存，则预减 redis 库存，检查是否已经生成订单，没有的话就将请求入消息队列
6. 从消息队列中取消息：获取商品 ID 和用户 ID，判断数据库库存，然后下单
7. 下单：数据库减库存，生成订单，将订单信息写入数据库和 redis
8. 前端轮询订单生成结果

## 分布式 Session 是怎么实现的

1. 用户登录后生成随机字符串（生成 UUID），并向 cookie 中写入此字符串
2. 在 Redis 中记录此字符串和用户信息的映射
3. 当用户再次访问网页时，取出 cookie 中对应字段值，根据此字段值访问 Redis 得到用户相关信息

## 如何解决超卖

- 主要依靠 MySQL 的排它锁，在减库存时在 update 语句中添加库存判断：`where stock > 0`
- 利用唯一索引，防止重复下单

## 如何解决重复下单

- 执行扣减库存下订单之前，查询 redis 判断是否有用户秒杀此商品的订单
- 利用唯一索引，在订单表中创建用户 ID 和 商品 ID 组成的唯一索引，这样在重复插入数据时会插入失败，之前的减库存操作在事务也会回滚

## 如何防刷

- 数学公式验证码
- 通用拦截器限流，记录用户在一段时间内对该接口的访问次数，如果超过设定值就直接返回“请求频繁”，进行限流

## 消息队列的作用

- 削峰，减小同一时刻并发量
- 实现异步下单，入队之后直接返回用户排队中的消息，提高用户体验

## 压测 / QPS

- JMeter 压测
- 10个线程，每个线程每秒5000并发量
- 云服务器，性能太差（1核2G）
- 虚拟机4核4G，未优化前：1100~1200QPS，优化后：2000QPS

## 库存预减用的是哪个redis方法

- 使用 Jedis 封装的方法，减库存使用`decr`方法

# 2.可能出现的问题

## 缓存和数据库数据一致性如何保证?

- 对于库存数据不需要保证，缓存中的库存只为了过滤请求，即使多放进来一些请求也可以在数据库层面保证不超卖
- 对于商品信息的静态数据不需要保证，因为不会变

## 如果项目中的redis服务挂掉，如何减轻数据库的压力

- 设置本地缓存
- 设置限流降级功能
- 做好参数校验

## 假如减了库存但用户没有支付，怎么将库存还原继续进行抢购

- 订单超时未支付则删除订单，增加库存数量，恢复 Redis 缓存和本地缓存的数量

# 3.可改进的地方

## 系统瓶颈 / 如何查找 / 如何再优化

- 系统瓶颈
  - 数据库
  - 服务端网络带宽，服务器的 CPU、内存等硬件资源
- 如何查找：通过查看服务器运行时的资源占用情况判断（`top`命令）
- 再优化
  - 对于服务端网络带宽可以向 ISP 购买，增加服务器硬件资源
  - 减小耗费 CPU 和内存的操作，避免创建大对象的操作，防止出现内存泄漏
  - CDN，动静态资源分离
  - Nginx，LVS

## 项目可改进之处

- 对于数据的动静态资源分离没有做彻底，只使用到了浏览器缓存，没有使用 CDN 等技术
- 没有设置服务降级的方案
- 限流做的还不够完善，项目里只是对用户对于某个商品的访问做了限流，没有对整体的流量做限流
- 没有考虑 redis 穿透的情况处理方案（使用布隆过滤器）
- 项目是对秒杀商品的库存和静态数据进行了预热，但实际中某些非秒杀商品可能在某时间段的访问量剧增，如果没有对这些商品数据进行预热可能会使服务宕掉，**需要进行热点数据的快速发现和隔离**

# 4.项目难点及问题解决

## 缓存击穿、缓存雪崩、缓存穿透、缓存一致性

> 使用了大量缓存，那么就存在缓存击穿、缓存雪崩、缓存穿透以及缓存一致性等问题

- **缓存击穿**：某个热点的 key 突然失效了，对其的大并发集中访问全部落在数据库上，导致数据库压力剧增
  1. 针对热点 key 失效：对于热点的 key 设置永不过期的 key
  2. 针对大并发访问：使用互斥锁。如果缓存失效，只有拿到锁才能查询数据库，降低同一时刻落在数据库上的请求；代价是导致系统的性能变差
- **缓存雪崩**：某一时刻出现大规模的 key 失效，大量请求直接落在数据库上，导致数据库压力剧增
  1. 针对 Redis 服务不可用
     - 搭建 Redis 集群，提高 Redis 的容灾性
     - 限流，避免同时处理大量的请求
     - 熔断机制，当流量达到一定阈值时，直接返回“系统拥挤”之类的提示
  2. 针对同一时刻的大规模缓存失效
     - 设置不同的失效时间，在原有的失效时间上加上随机值
     - 对热点 key 设置永不过期
- **缓存穿透**：大量请求的 key 不存在于缓存中，导致大量请求直接落在数据库上，根本没有经过缓存
  1. 做好参数校验，对于非法的参数请求直接抛出异常信息返回客户端
  2. 把无效的 key 存入缓存并设置过期时间，适用于请求的 key 变化不频繁的情况，**缺点**是如果请求的无效 key 每次都是随机的，会导致 Redis 中缓存大量无效的 key
  3. **在查询缓存之前使用布隆过滤器**。布隆过滤器判断某个 key 不存在，那么一定不存在；布隆过滤器判断某个 key 存在，则大概率存在（小概率误判，因为不同元素可能哈希出来的位置相同）
     - 降低布隆过滤器的误判概率：适当增加位数组的大小；调整哈希函数
- **保证缓存和数据库数据的一致性**
  1. 先更新数据库，再删除缓存
  2. 如果更新数据库成功，但删除缓存这一步失败的解决方案
    - 增加缓存更新重试机制：缓存服务不可用导致缓存删除失败，就隔一段时间进行重试；多次重试还是失败，可以把当前更新失败的 key 存入队列，等缓存服务可用之后，再将缓存中对应的 key 删除即可

## 如何减少redis访问

> 大量的使用缓存，对于缓存服务器也有很大的压力，如何减少redis的访问？

- 使用内存标记，利用`HashMap`，未卖完时，把商品 ID 设置为`false`；卖完时，设置为`true`
- 每次查询库存不是直接访问 Redis，而是先进行条件判断

## 如何解决请求堆积

> 在高并发请求的业务场景，大量请求来不及处理，甚至出现请求堆积的情况

1. 增加更多的消费者，提高消费速度
2. 给消费者开启线程池，提高消费速度
3. 利用惰性队列 Lazy Queues，扩大队列容积，提高堆积的上限

## 页面静态化的过程

- 使用纯 html 页面，Ajax 动态请求 JSON 数据填充页面

## 秒杀接口隐藏的过程

- 用户点击秒杀按钮时向服务器请求秒杀路径
- 服务器生成随机 path，结合用户 ID 和商品 ID 之后存入 Redis
- 前端获取到秒杀路径后，根据秒杀路径调用秒杀服务
- 服务器根据用户 ID 和 商品 ID 查询 Redis，判断秒杀路径是否一致