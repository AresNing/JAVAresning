秒杀项目总结及面试常见问题

前言：

这篇文章是慕课网秒杀项目的总结，主讲人是Joshua，B站上搜Java秒杀就可以获取资源，为了防止链接过期，这里就不贴链接了，大家自己可以去B站搜
秒杀项目的思路大致是一样的，只是有些功能更齐全，核心思想都是解决高并发，所以可能项目不同但是同样有借鉴作用
本文主要对逻辑进行梳理，不包含代码
文末有总结好的常见的面试题
项目亮点
使用分布式Session，可以实现让多台服务器同时可以响应
使用redis做缓存提高访问速度和并发量，减少数据库压力，利用内存标记减少redis的访问
使用页面静态化，加快用户访问速度，提高QPS，缓存页面至浏览器，前后端分离降低服务器压力
使用消息队列完成异步下单，提升用户体验，削峰和降流
安全性优化：双重md5密码校验，秒杀接口地址的隐藏，接口限流防刷，数学公式验证码
秒杀流程
登录进入商品列表页面，静态资源缓存
点击进入商品详情页面，静态资源缓存，Ajax获取验证码等动态信息
点击秒杀, 将验证码结果和商品ID传给后端，如果结果正确。动态生成随机串UUID,结合用户ID和商品ID存入redis，并将path传给前端。前端获取path后，再根据path地址调用秒杀服务
服务端获取请求的path参数，去查缓存是否在
如果存在，并且Redis还有库存，预减redis库存，看是否已经生成订单，没有的话就将请求入消息队列
从消息队列中取消息：获取商品ID和用户ID，判断数据库库存，然后下单
下单：减库存，生成订单
前端轮询订单生成结果。50ms继续轮询或者秒杀是否成功和失败
一. 环境的搭建
二. 登录功能的实现
主要内容

数据库设计
明文密码两次MD5处理
JSR303参数检验+全局异常处理
分布式Session
数据库设计

不做注册，直接登录，在MySQL中直接创建表
用户表包括id、nickname、password、salt、头像、注册时间、上次登录时间、登录次数等字段
对登录密码进行两次MD5：细节描述

加密的目的：第一次是因为http是明文传输的，第二次为了防止数据库被盗
JSR303参数检验

通过对输入的参数LoginVo加注解@validated，然后在传入的参数mobile和password上加上注解判断，如@NotNull判断是否为空，也可以自定义
全局异常处理
分布式Session？

**三. 实现秒杀功能**
主要内容
数据库设计
商品列表页
商品详情页
订单详情页
数据库设计
包括商品表、商品表订单表、秒杀商品表、秒杀商品订单表
商品列表页
为了展示秒杀商品的详情需要goods和miaosha_goods中的信息，所以封装一个GoodsVo，包括价格、库存、秒杀起始时间
商品详情页

订单详情页

这里也是秒杀功能的实现
在控制层先判断库存、然后判断订单是否存在、如果都没有就下单
下单顺序为减库存、下定单、写入秒杀订单
四. JMeter压测
主要内容
JMeter入门
自定义变量模拟多个用户
JMeter命令行使用
Redis压测工具redis-benchmark
Spring Boot打war包
JMeter入门
JMeter在windows下是图形界面
打开jmeter.bat运行图形界面
测试计划中添加线程组
在线程组中添加HTTP请求默认值（就是端口号）
在线程组中添加HTTP请求（就是要测试的类的URL）、这里可以设置带参数
在线程组中添加监听器进监听
也可以通过自定义模拟多用户（写一个文件，导入即可）
JMeter在Linux下是命令行进行操
在Windows上录好jmx
命令行：sh jmeter.sh -n -t XXX.jmx -l result.jtl
把result.jtl导入到jmeter
结果是五千并发的情况下，QPS为一千三左右
Redis压测工具redis-benchmark
redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000
-c为100个并发连接，-n为100000个请求
Redis的QPS在十万左右

**五. 页面优化技术**
内容

页面缓存+URL缓存+对象缓存（缓存粒度：页面缓存 > URL缓存 > 对象缓存）
页面静态化（html缓存在客户端，ajax请求），前后端分离
静态资源优化
CDN优化

**页面缓存+URL缓存+对象缓存**

秒杀的瓶颈在于数据库，所以要加上各种粒度的缓存，最大的是页面缓存、最小的是对象缓存

**页面缓存步骤（这里指的是商品列表）：**
从redisService中取缓存
若缓存中没有则手动渲染，利用thymeleaf模板
然后将页面加入缓存，并返回渲染页面
不宜时间太长，设置为60s即可

**URL缓存（指的是商品详情页）**
与页面缓存步骤基本一致，但是需要取缓存和加缓存时要加入参数，GoodsId

**对象缓存（指的是User对象**）
前面的页面缓存和URL缓存适合变化不大的，缓存时间比较短

对象缓存是长期缓存，所以需要有个更新的步骤
第一步是取缓存
若缓存中没有则去数据库中查找，并加入缓存；如数据库中没有就报错
更新用户的密码
加缓存之后的QPS大概3000
需要先更新数据库，后删除缓存；顺序不能反，会导致数据不一致：若线程1先删除缓存，然后线程2读操作，发现缓存中没有，把数据库中的旧数据加入缓存，然后线程1更新数据库，就会导致缓存与数据库数据不一致

**页面静态化，前后端分离**

页面静态化无非就是使用纯html页面+Ajax请求json数据后再填充页面
若A页面跳转到B页面之前需要条件判断可以先在A页面中利用ajax请求判断后再跳转
如果不需要条件判断可以直接跳转到B的静态页面，让B自己用ajax请求数据

**防超卖**

发生在减库存的时候
解决方法是在Update语句中加一个判断
![image-20211229210209794](pics/image-20211229210209794.png)

还有一种情况是一个用户同时发了两个请求，假如库存充足，且没有订单生成，那么就会减两次库存
解决办法是建立用户和商品的唯一索引
做到以上两点是不会发生超卖的（最后还是依靠数据库来实现数据一致）

![image-20211229214933826](pics/image-20211229214933826.png)

**静态资源优化**

- JS/CSS压缩（去掉一些空格、注释等不必要的字符），减小流量，减小页面体积
- 多个JS/CSS组合，减小连接数（加载页面时如果需要加载多个JS/CSS，一般情况向服务器请求的并发数会很小，所以会和服务器建立多次连接；而TCP连接是三次握手，耗时较长；会导致首次加载页面时的加载速度较慢）
  - Tengine，淘宝开源项目；webpack，前端打包工具

![image-20211229213742313](pics/image-20211229213742313.png)

- CDN（内容分发网络）就近访问

**CDN优化**

CDN是内容分发网络，相当于缓存，只是部署在全国各地，当用户发起请求时，会找最近的CDN获取资源
**总结：**并发大的瓶颈在于数据库，所以解决办法是加各种缓存：从浏览器开始，做页面的静态化，将静态页面缓存在浏览器中；请求到达网站之前可以部署一些CDN，让请求首先访问CDN；然后是页面缓存、URL缓存、对象缓存；
加缓存的缺点：数据可能不一致，只能做一个平衡

**六. 接口优化**
内容

Redis预减库存减少数据库访问
内存标记减少Redis访问
RabbitMQ队列缓冲，异步下单，增强用户体验
RabbitMQ安装与Spring Boot集成
访问Nginx水平扩展
压测
（还有一种方法：数据库的分表分库，阿里巴巴中间件 mycat）

思路：减少数据库访问

1. 系统初始化，把商品库存数量加载到Redis中
2. 收到请求，Redis预减库存，库存不足，直接返回，否则进入3
3. 请求入队，立即返回排队中
4. 请求出队，生成订单，减少库存
5. 客户端轮询，是否秒杀成功

优化思路

1. 系统初始化，把商品库存数量加载到Redis
2. 收到请求，Redis预减库存，库存不足，直接返回，否则进入3
3. 请求入队，立即返回排队中（异步下单）
4. 请求出队，生成订单，减少库存，把订单写入Redis中
5. 客户端轮询，判断是否秒杀成功

秒杀接口优化

之前的没有库存预热的步骤是：查库存-查订单-修改库存-生成订单
系统初始化时把库存加载到数据库：MiaoshaController 继承InitializingBean实现afterPropertiesSet方法即可
在上一步库存预热之后，执行步骤为：查Redis库存-判断是否存在订单-进入队列-在出队时才对数据库进行操作
这一步还可以有一个优化，就是内存标记，使用一个Map，将商品ID设置为false，当买空时，设为true；然后每次不是直接访问Redis进行库存查询，而是对商品ID进行条件判断
内存标记的优点是减少对Redis的访问（当商品已经卖完之后）

**七. 安全优化**
主要内容

秒杀接口地址隐藏
数学公式验证码
接口限流防刷
秒杀接口地址隐藏

虽然前端页面在秒杀未开始时秒杀按钮设置为不可用，但是有可能用户通过前端js代码找到秒杀地址在秒杀未开始时直接访问，秒杀接口隐藏的目的是用户通过js获取到的秒杀地址并不能让其完成秒杀功能
在秒杀之前要先通过Controller中的/path路径下的类随机生成一个path，然后和用户ID一起存入Redis，在执行秒杀的时候再从Redis中取Path进行验证，然后进行秒杀
数学公式验证码

作用：接口防刷；错开请求
在获取Path是进行验证
接口限流防刷

当一个用户访问接口时，把访问次数写入缓存，并设置有效期
一分钟之内如果用户访问，则缓存中的访问次数加一，如果次数超限进行限流操作
如果一分钟内没有超限，缓存中数据消失，下次再访问时重新写入缓存
使用一个通用拦截器

首先写一个注解AccessLimit
后面每个类只需要加注解即可设置防刷次数
定义拦截器：继承HandlerInterceptorAdapter类
八. 总结
1.问题总结（主要从三个方面：项目本身的问题、可能出现的问题、可改进的地方）

1.1 项目本身的问题

画一下项目的架构图
讲一下秒杀流程
秒杀模块怎么设计的
秒杀部分是怎么做的
分布式Session是怎么实现的
如何解决超卖？mysql锁
如何解决重复下单？mysql唯一索引
如何防刷？验证码+通用拦截器限流
消息队列的作用？异步削峰
压测没有？用什么压测？QPS是多少？
库存预减用的是哪个redis方法
1.2 可能出现的问题

缓存和数据库数据一致性如何保证？
如果项目中的redis服务挂掉，如何减轻数据库的压力
假如减了库存但用户没有支付，怎么将库存还原继续进行抢购
1.3 可改进的地方

系统瓶颈在哪？如何查找，如何再优化？
除了你项目里面的优化，你还有什么优化策略吗？（同上一个问题）
项目难点及问题解决
使用了大量缓存，那么就存在缓存击穿和缓存雪崩以及缓存一致性等问题
大量的使用缓存，对于缓存服务器也有很大的压力，如何减少redis的访问
在高并发请求的业务场景，大量请求来不及处理，甚至出现请求堆积的情况
怎么保证一个用户不能重复下单
怎么解决超卖现象
页面静态化的过程

# 补充

- 对于每次都要进行的参数验证（如检查user是否为空），可以写一个注释作为拦截器（如@NeedLoginIn）用于参数检验
- vo文件夹下的xxxVo类是结果封装类，用于组合不同类的信息