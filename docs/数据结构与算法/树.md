# 树的概念

## 树的定义

- 用递归定义：树是由根结点和若干个棵子树构成的

- 树的表示方法：树型表示法、文氏图表示法、凹入图表示法、广义表表示法

  ![树的表示方法](pics/image-20210630212758607.png)

## 基本术语

- 结点的度（degree）：一个结点的子树个数
  - 树的度：一棵树中结点度的最大值
  - 叶子（leaf）/终端结点：度为零的结点
- 儿子（child）：树中结点的后继结点
- 父亲（parents）：结点的前趋结点
  - 兄弟（sibling）：同一个父亲的儿子
- 路径（path）：树中存在的结点序列，路径的长度为该路径经过的边（即连接两个结点的线段）的数目（即结点数减1）
- 结点的祖先（ancestor）：从根结点到该结点路径上所经过的所有结点
- 结点的子孙（descendant）：以该结点为根的子树中的所有结点
- 结点的层数（level）：从根开始算起
  - 树的高度（height）/深度（depth）：树中结点的最大层数
- 有序树（Ordered Tree）：树中每个结点的各子树看成从左到右有次序的（即不能互换），否则为无序树（Unordered Tree）
- 森林（forest）：$m(m\geq0)$棵互不相交树的集合

# 二叉树的定义

## 定义

- 二叉树是由$n(n\geq0)$结点组成的有限集合，此集合或者为空，或者由一个根结点加上两颗分别称为左、右子树的，互不相交的二叉树组成

![二叉树的5种形态](pics/image-20210701102910907.png)

## 二叉树与一般树的结构区别

- 二叉树可以为空树，即不包括任何结点；一般树至少应有一个结点
- 二叉树区别于度数为2的有序树，二叉树允许某些结点只有右子树而无左子树
- **二叉树并非是树的特殊情况，两者为不同的数据结构**

# 二叉树的性质

- 二叉树第$i(i\geq1)$层上的结点数最多为$2^{i-1}$
- 高度为$k$的二叉树最多有$2^k-1$个结点
- 对任何二叉树$T$，设$n_0$、$n_1$、$n_2$分别表示度数为0、1、2的结点个数，则$n_0=n_2+1$
- 具有$n$个结点的完全二叉树（包括满二叉树）的高度为$floor(log_2n)+1$或者$ceil(log_2(n+1))$
- 满二叉树原理：非空满二叉树的叶结点数等于分支结点数加1
- 一颗非空二叉树的空子树的数目等于其结点数目加1

## 满二叉树

- 满二叉树：深度为$k$且有$2^k-1$个结点的二叉树
- 满二叉树每一层上的结点都达到最大值
- 叶子都在最下一层

![满二叉树](pics/image-20210701104151869.png)

## 完全二叉树

- 完全二叉树：若一颗二叉树至多只有最下面的两层结点的度数可以小于2，且最下一层上的结点都集中在该层最左边的若干位置上
- 满二叉树是完全二叉树，完全二叉树不一定是满二叉树

![完全二叉树](pics/image-20210701104404104.png)

## 二叉树的抽象数据类型

- `BinNode`类：二叉树结点的java接口

```java
interface BinNode { // 二叉树结点的抽象数据类型
    // 返回并设置元素值
    public Object element;
    public Object setElement(Object v);
    
    // 返回并设置左子结点
    public BinNode left();
    public BinNode setLeft(BinNode p);
    
    // 返回并设置右子结点
    public BinNode right();
    public BinNode setRight(BinNode p);
    
    // 判断是否为叶结点
    public boolean isLeaf();
}
```

# 二叉树的存储结构

## 二叉树的顺序存储结构

- 二叉树顺序存储的原则：不管给定的二叉树是不是完全二叉树，都看作完全二叉树，即按完全二叉树的层次次序（从上到下、从左到右）把各结点一次存入数组中

  ![二叉树的顺序存储](pics/image-20210701111116954.png)
  
- 存储一般二叉树造成大量存储空间浪费

## 二叉树的链式存储结构

- 二叉树的链式存储中每个结点有数据域和指针域组成，指针域有两个：左子结点和右子结点（`lchild - data - rchild`）
- 二叉树的链式存储也称为二叉链表
- 具有$n$个结点的二叉树中，一共有$2n$个指针域，其中$n-1$个存储指针，$n+1$个指针域为空
  - 若二叉树为空，则根结点为`null`
  - 判断叶结点：`(Lchild == null) && (Rchild== null)`

# 二叉树的实现

## 二叉树实现原则

1. 以第一个建立的元素为根结点
2. 以次序将元素值与根结点做比较
   - 若**元素值大于根结点值，则元素值往根结点的右子结点移动**，若右子结点为空，则将元素值插入；否则继续向下比较，直至插入适当的空结点
   - 若**元素值小于根结点值，则元素值往根结点的左子结点移动**，若左子结点为空，则将元素值插入；否则继续向下比较，直至插入适当的空结点

## 以数组方式实现二叉树的顺序存储

- 根结点下标为`1`，其余结点遵循左小（`level*2`）右大（`level*2+1`）

```java
class BiTreeArray {
    int maxSize = 16; // 自定义数组大小
    int[] ABiTree = new int[maxSize];
    
    public void BiTreeArray() {
        for(int i = 0; i < maxSize; i++) ABiTree[i] = 0;
    }
    
    public void create(int Data) {
        int level = 1; // 根结点下标为1
        while(ABiTree[level] != 0) { // 判断是否存在子树
            if(Data < AbiTree[level])
                level = level * 2; // 左子树
            else
                level = level * 2 + 1; // 右子树
        }
        ABiTree[level] = Data; // 将元素值插入结点
    }
}
```

## 以数组方式实现二叉树的链式存储

- 结点数组的元素结构：`lchild - data - rchild`
- 根结点的下标为`0`
- 若子结点不存在则`lchild / rchild`存值为`-1`
- 插入或删除结点时只要改变`lchild / rchild`的值，而不需要大量移动数据

```java
class BiTreeArray {
    int maxSize = 16; // 自定义数组大小
    int[] treeData = new int[maxSize];
    int[] leftNode = new int[maxSize];
    int[] rightNode = new int[maxSize];
    
    public BiTreeArray() {
        for(int i = 0; i < maxSize; i++) {
            treeData[i] = 0;
            leftNode[i] = 0;
            rightNode[i] = 0;
        }
    }
    
    public void creat(int data) {
        int level = 0; // 树的层数
        int position = 0;
        
        for(int i = 0; treeData[i] != 0; i++) {
            treeData[i] = data;
        }
        
        while(true) { // 寻找结点位置
            if(data < treeData[level]) {
                // 右子树是否有下一层
                if(rightNode[level] != -1) 
                    level = rightNode[level];
                else {
                    position = -1; // 设置为右子树
                    break;
                } 
            }
            else {
                // 左子树是否有下一层
                if(leftNode[level] != -1)
                    level = leftNode[level];
                else {
                    position = 1; // 设置为左子树
                    break;
                }
            }
        }
        if(position == 1)
            leftNode[level] = i; // 连接左子树
        else
            rightNode[level] = i; // 连接右子树
    }
}
```

# 二叉树的遍历

*示例二叉树*

![image-20210703212953115](pics/image-20210703212953115.png)

## 二叉树的前序遍历

- 前序遍历（Preorder Traversal）：先遍历根结点，再遍历左子树，最后遍历右子树
- 示例二叉树的遍历顺序为：`A - B - D - G - C - E - H - F - I`

## 二叉树的中序遍历

- 中序遍历（Inorder Traversal）：先遍历左子树，再遍历根结点，最后遍历右子树
- 示例二叉树的遍历顺序为：`G - D - B - A - H - E - C - F - I`

## 二叉树的后序遍历

- 后序遍历（Postorder Traversal）：先遍历左子树，再遍历右子树，最后遍历根结点
- 示例二叉树的遍历顺序为：`G - D - B - H - E - F - I - C - A`

## 二叉树的层次遍历

- 层次遍历：从二叉树的第一层（根结点）开始，从上至下逐层遍历，同一层中则按从左到右的顺序逐个访问结点
- 在进行层次遍历时，对一层结点访问完后，再按照他们的访问次序对各个结点的左子结点和右子结点顺序访问，就完成了对下一层的访问
- 示例二叉树的遍历顺序为：`A - B - C - D - E - F - G - H - I`

### 队列实现

1. 初始化一个队列
2. 二叉树的根结点放入队列
3. 从队列中取出一个结点`x`
4. 访问结点`x`
5. 如果`x`存在左子结点，将左子结点放入队列
6. 如果`x`存在右子结点，将右子结点放入队列
7. 重复步骤3~6直至队列为空

# 线索二叉树

- 线索：利用二叉链表的空指针域来存放结点的前趋结点和后继结点的指针信息，附加的指针称为"线索"

  - 规定：当某结点的**左/右指针域为空**时，令其指向依某种方式遍历时所得到的**该结点的前趋/后继结点**
- 线索链表：增加了线索的二叉链表
- 线索二叉树（Threaded Binary Tree）：线索链表对应的二叉树

## 线索链表的结点结构

`lchild - ltag - data - rtag - rchild`（标志位只占1个`bit`）

  - 左线索标志
    - `ltag = 0`：`lchild`是指向结点的左子结点的指针
    - `ltag = 1`：`lchild`是指向结点的前趋结点的左线索
- 右线索标志
  - `rtag = 0`：`rchild`是指向结点的右子结点的指针
  - `rtag = 1`：`rchild`是指向结点的后继结点的右线索
- **通常在二叉树中增加一个与树中结点相同类型的头结点**
  - 头结点的信息域为空
  - 令原本指向二叉树根结点的头指针指向该头结点
  - `lchild`域指向二叉树的根结点，当二叉树为空时，`lchild`域值为空
  - `rchild`域指向以某种方式遍历二叉树时最后访问的结点，当二叉树为空时，`rchild`域指向该结点本身
  - 以某种方式遍历二叉树时**第一个被访问结点的左指针域**和**最后一个被访问结点的右指针域**的值如果是**线索**，也**指向该头结点**

## 线索二叉树上的运算

*以中序线索二叉树为例*

1. 建立一棵中序线索二叉树
   - 首先申请一个头结点，建立头结点与二叉树根结点的线索
   - 二叉树线索化后，建立最后一个结点与头结点之间的线索
2. 在中序线索二叉树上寻找任意结点的中序前趋结点
   - 前趋结点是以该结点的左子结点为根结点的子树的最右结点
   - 沿着其左子树的右指针链向下查，当某结点的右标志为1时，它就是要找的前趋结点
3. 在中序线索二叉树上寻找任意结点的后继结点
   - 后继结点是以该结点的右子结点为根结点的子树的最左结点
   - 沿着其右子树的左指针链向下查，当某结点的左标志为1时，它就是要找的后继结点
4. 在中序线索二叉树中查找值为`x`的结点
   - 利用在中序线索二叉树上寻找后继结点的算法
   - 设置一指针变量`p`，开始时指向二叉树的根结点，结束条件为`p`所指结点的信息域值为`x`或`p == head`
5. 在中序线索二叉树上插入结点
   - 主要操作是修改指向子结点的指针和指向前趋/后继结点的线索
   - 指向子结点的指针修改容易，线索的修改有时花费较大，另一种方法：对插入和删除后的二叉树重新进行线索化

# 树和二叉树的转化及树的存储结构

*示例一般树*

![示例一般树](pics/image-20210704200832070.png)

## 树转换为二叉树

1. 树中所有相邻兄弟之间加一条连线
2. 对树中的每个结点，只保留它与第一个子结点之间的连线，删去它与其他子结点之间的连线
3. 以树的根结点为轴心，将整棵树顺时针转动一定的角度，使之结构层次分明

- 变换后的二叉树的根结点的右子结点始终为空

![树转换为二叉树](pics/image-20210704203409074.png)

## 二叉树还原为树

1. 若某结点是其父结点的左子结点，则把该结点的右子结点、右子结点的右子结点...都与该结点的父结点

## 森林转换为二叉树

## 树的遍历

## 森林的遍历

## 树的存储结构

# 哈夫曼树及其应用





















