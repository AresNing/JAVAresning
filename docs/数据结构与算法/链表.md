# 单向链表

## 节点类的定义

```java
class Link {
    private Link next;
    private Object item;
    Link(Object item, Link next) {
        this.item = item;
        this.next = next;
    }
    Link(Link next) { this.next = next;}
    Link next() { return this.next;}
    link setNext(Link next) {return this.next = next;}
    Object item() { return this.item;}
    Object setItem(Object item) { return this.item = item;}
}
```

## 建立链表

### 尾插入法

- 优点：固定头指针`head`，不会因为不断修改头指针，而造成头指针的丢失
- 缺点：将新节点插到当前链表的表尾，必须增加一个尾指针`tail`的开销，使其指向当前链表的尾节点

```java
public void insert(Object item) { // 插入一个元素
    curr.setNext(new Link(item, curr.next()));
    if(tail == curr) tail = curr.next();
}
public void append(Object ietm) { // 末尾添加一个元素
    tail.setNext(new Link(item, null));
    tail = tail.next();
}
```

### 头插入法

- 优点：链表的第一个位置上的操作和表的其他位置上的操作一致，无须进行特殊处理；空表和非空表的处理统一；不需要增加`tail`的开销
- 缺点：需要不断修改头指针

```java
public void insert(Object item) { // 插入一个元素
    curr.setNext(new Link(item, head));
    if(head != curr) head = curr;
}
```

## 查找运算

### 按序号查找

```java
public int nexti() {
    int j = 0;
    curr = head;
    while((j != i) && (curr != null)) {
        j++;
        curr = curr.next;
    }
    if(curr = null) return 0;
    else return j;
}
```

### 按数值查找

```java
public Link nextval() {
    curr = head;
    while((curr.val != key) && (curr != null)) {
        curr = curr.next;
    }
    if(curr = null) return null;
    else return curr;
}
```

## 删除节点

```java
public Object remove() {
    if(!((curr != null) && (curr.next()!=null)) return null;
    Object item = curr.next().item();
    if(tail = curr.next()) tail = curr;
    curr.setNext(curr.next().next()); // 删除节点
    return item;
}
```

# 循环链表

- 通常在循环链表**以末尾节点指针为已知条件**，而不是头节点，方便**删除末尾节点**、**在第一个节点前插入新节点**

- 循环链表末尾节点的判定条件是其指针域指向头节点

  ```java
  curr.next() == head;
  ```

# 双向链表

- 每个节点里增加一个指向其直接前趋的指针域`prev`

## 节点类定义

```java
class DLink {
    private Object item;
    private DLink next;
    private DLink prev;
    DLink(Object item, DLink next; DLink prev) {
        this.item = item;
        this.next = next;
        this.prev = prev;
    }
    ...
}
```

## 插入节点

```java
public void insert(Object item) {
    curr.setNext(new DLink(item, curr.next(), curr));
    if(curr.next().next() != null) {
        curr.next().next().setPrev(curr.next());
    }
    if(tail == curr) tail = tail.next();
}

public void append(Object item) {
    tail.setNext(new DLink(item, null, tail));
    tail = tail.next;
}
```

## 删除节点

```java
public Object remove() {
    Object item = curr.next().item;
    if(curr.next().next() != null) {
        curr.next().next().setPrev(curr);
    }
    else tail = curr;
    curr.setNext(curr.next().next());
    return item;
}
```

## 查询节点

```java
public DLink dlinkSearch() {
    curr = head;
    while((curr != null) && (curr.item() != key)) {
        curr = curr.next;
    }
    if(curr == null) return null;
    else return curr;
}
```



---

**对于单链表相关的题目，双指针的运用是非常广泛**

---

# 合并两个有序链表

> [21. 合并两个有序链表 - LeetCode](https://leetcode-cn.com/problems/merge-two-sorted-lists/)
>
> 将两个升序链表合并为一个新的 **升序** 链表并返回

```java
ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    // 虚拟头节点
   	ListNode dummy = new ListNode(-1), p = dummy;
    ListNode p1 = l1, p2 = l2;
    
    while(p1 != null && p2 != null) {
        // 比较 p1 和 p2 两个指针
        // 将值较小的的节点接到 p 指针
        if(p1.val > p2.val) {
            p.next = p2;
            p2 = p2.next;
        } else {
            p.next = p1;
            p1 = p1.next;
        }
        // p 指针不断前进
        p = p.next;
    }
    
    if(p1 != null)
        p.next = p1;
    
    if(p2 != null)
        p.next = p2;
   	
    return dummy.next;
}
```

# 合并 k 个有序链表

> [23. 合并K个升序链表 - LeetCode](https://leetcode-cn.com/problems/merge-k-sorted-lists/)
>
> 一个链表数组，每个链表都已经按升序排列，请将所有链表合并到一个升序链表中，返回合并后的链表

## 算法分析

- 利用**优先队列（二叉堆）**，将链表节点放入小顶堆，每次获得`k`个节点中的最小节点
- 优先队列`pq`中的元素个数最多是`k`，所以一次`poll`或者`offer`方法的时间复杂度是$O(logK)$；所有的链表节点都会被加入和弹出`pq`
- 时间复杂度为$O(NlogK)$，空间复杂度为$O(K)$，$N$为链表的节点总数，$K$是链表的条数

```java
ListNode mergeKLists(ListNode[] lists) {
    if(lists.length == 0) return null;
    // 虚拟头节点
    ListNode dummy = new ListNode(-1), p = dummy;
    // 优先队列, 最小堆
    PriorityQueue<ListNode> pq = new PriorityQueue<>(lists.length, (a, b) -> (a.val - b.val)); // Lambda 表达式
    // 将 k 个链表的头节点加入最小堆
    for(ListNode head : lists) {
        if(head != null)
            pq.offer(head);
    }
    
    while(!pq.isEmpty()) {
        // 获取最小节点, 接到结果链表中
        ListNode node = pq.poll();
        p.next = node;
        if(node.next != null)
            pq.offer(node.next);
        // p 指针不断前进
        p = p.next;
    }
    return dummy.next;
}
```

# 单链表的倒数第 k 个节点

## 算法分析

- **双指针（快慢指针）**，快指针`fast`比慢指针`slow`先走`k`步，然后`fast`和`slow`同时向前走
- 当`fast`走到链表末尾的空指针时走了`n-k`步，`slow`恰好到达链表的倒数第`k`个节点

```java
// 返回链表的倒数第 k 个节点
ListNode findFromEnd(ListNode head, int k) {
    ListNode fast = head;
    // fast 先走 k 步
    for (int i = 0; i < k; i++) {
        fast = fast.next;
    }
    ListNode slow = head;
    // fast 和 slow 同时走 n - k 步
    while (fast != null) {
        slow = slow.next;
        fast = fast.next;
    }
    // slow 现在指向第 n - k 个节点
    return slow;
}
```

# 单链表的中点

> [876. 链表的中间结点 - LeetCode](https://leetcode-cn.com/problems/middle-of-the-linked-list/)











