# 栈 Stack

- 栈是特殊的线性表
- 栈的操作只在栈的一端操作，运算实现比线性表方便
- 栈顶指针指向栈顶元素的下一个位置

## 栈的基本运算

- `initStack(S)`：构造一个空栈`S`，即`new`
- `clearStack(S)`：清空堆栈，栈顶指针置0
- `stackEmpty(S)`：判栈空，若`S`为空栈返回`true`，否则返回`false`
- `stackFull(S)`：判栈满，若`S`为满栈返回`true`，否则返回`false`
- `push(S, x)`：进栈。若栈`S`不满，则将元素`x`压入`S`的栈顶
- `pop(S)`：退栈。若栈`S`非空，则将`S`的栈顶元素弹出，并返回该元素
- `stackTop(S)`：取栈的栈顶元素，不修改栈顶指针

## 顺序栈 array-based stack

- 顺序栈需要考虑栈的上溢
- 避免浪费空间，可以用一个数组来存储两个栈，每个栈从各自的端点向中间延伸，同时增加了栈溢出的风险

## 链式栈 linked stack

- 链式栈需要考虑栈的下溢
- 链式栈的元素只能在表头进行插入和删除，栈顶指针指向链式栈的头节点

## 顺序栈和链式栈的对比

- 两者操作的时间复杂度都是$O(1)$
- 顺序栈需要固定长度，容易造成空间浪费；链式栈长度可变，比较节省空间，但每个节点设置了一个指针域，产生了结构开销

# 队列

- 非空队列中，头指针指向队首元素，尾指针指向队尾元素的下一个位置
- 假溢出：入队和出队操作中，头尾指针不断增加而不减小或只减小而不增加，使得被删除元素的无法被重新利用，最后造成队列中有空闲空间，但不能够插入元素，也不能够删除元素的现象

## 队列的基本运算

- 置空队：构造一个空队列，即`new`
- 判队空：队空返回`true`，否则返回`false`
- 判队满：队满返回`true`，否则返回`false`
- 入队：队列非满时，从队尾插入元素
- 出队：队列非空时，从队首删除元素
- 取队首元素：返回队首元素，不修改队首指针

## 顺序队列

- 使用循环队列解决"假溢出"

